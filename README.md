Note: maybe I'll translate this at some point, it's nothing would
interest people I guess.

A friend asked me to implement and it was fun to think about the
combinatorial problem.

Idea is: generate permutations of "seatings" for students / course participants etc.

Never repeat the same seat number.

There are as many seats as there are students.

Optimal solution is Latin squares, which can be generated by brute force using backtracking.

This also shows how dead ends become increasingly likely when simply randomly changing the permutations
as the number of seats / students grows.

https://paperclip-factory.de/permutations

# Sitzordnungen und Lateinische Quadrate

Angenommen, es gibt genau so viele Plätze wie Kursteilnehmer: wie viele
"zufällige" Sitzordnungen können wir erzeugen, ohne dass ein Teilnehmer
jemals zwei mal auf dem gleichen Platz sitzt?

Die einfachste Möglichkeit, um die maximale Anzahl an Sitzordnungen zu
erhalten, ist natürlich, die Plätze einfach zu rotieren.

Dann gibt es genau so viele Sitzordnungen wie Plätze.

Aber wir wollten ja "zufällige" Sitzordnungen. Wie man sich intuitiv
schon denken kann, ist es immer möglich, **n** Sitzordnungen für
**n** Plätze zu finden, die das Kriterium erfüllen.

Aber was passiert, wenn man "ungünstig" umsetzt?

Wie man leicht sieht, landet man dann bei weniger Möglichkeiten.

Diese App war ein Spaß, um nach einem Gespräch mit einem Freund
die "Sackgassen" zu zeigen, und wie man das Problem löst,
ohne alle Möglichkeiten durchprobieren zu müssen (trotzdem per Brute force, also
mit Backtracking).

Aktuell im Web auf

https://paperclip-factory.de/permutations
